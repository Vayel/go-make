# go-make

A parallel version of the `make` tool in Go which uses RPC. Works with
basic Makefiles only (see below).

To compare with a sequential execution, we developped a sequential version, in
the folder `sequential`.

The parallel implementation is based on a master-slave architecture. The master
parses the Makefile and waits for slaves to ask for tasks. If a rule is ready
(whose dependencies are all computed), the master returns it.

The communication relies on the RPC protocol. The master starts a RPC server and
exposes two methods:

* `giveTask`: a slave asks for work, the master returns a ready rule. If there
are none, it appends the slave in a waiting list.
* `receiveResult`: a slave returns the result of a rule (the generated file). If
other rules become ready, the master wakes up the waiting slaves and waits for
them to ask for work.

Our program does not manage failures. If a slave crashes, the master may not
end.

# Install

Dependencies:

* Go

To compile the sequential version:

```bash
make sequential
```

For the parallel one:

```bash
make
```

# Run

## Master

```bash
make run_master makefile-path
```

For instance:

```bash
make run_master makefiles/8
```

## Slave

```bash
make run_slave1
# Or: make run_slave2
```

# Supported Makefiles

This tool handles only basic Makefiles. All rules must look like:

```
target: dep1 dep2 dep3 ...
	instruction1
	instruction2
	...
```

All rules must create a file of the same name. If a rule needs an
external file (which is not generated by a dependency), for instance some code
to be compiled, we consider it has been transfered beforehand. The same applies
for the instructions: all commands called by the rules must be available on
the machines.

A rule may not have any dependency (it is mandatory for at least one in fact). The
instructions must be directly interpretable by the program `sh`. In particular,
our program does not manage variables in Makefiles.
